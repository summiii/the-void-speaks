# -*- coding: utf-8 -*-
"""DBpro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O4q0Xgz7MI4TKrydyWYYJSRX2LCxdRIM
"""

from pathlib import Path
import sqlite3

print("CWD:", Path.cwd())
ASSETS = Path("/content/assets")
DB     = Path("/content/music.db") if Path("/content/music.db").exists() else Path("music.db")
print("ASSETS:", ASSETS.resolve(), "exists:", ASSETS.exists())
print("DB:", DB.resolve(), "exists:", DB.exists())

with sqlite3.connect(DB) as con:
    cols = [r[1] for r in con.execute("PRAGMA table_info(tracks);")]
    print("tracks columns:", cols)
    n = con.execute("SELECT COUNT(*) FROM tracks").fetchone()[0] if cols else 0
    print("current track count:", n)

import requests, time

def discover_first_jobs(query, max_releases=2):
    session = requests.Session()
    adv = "https://archive.org/advancedsearch.php"
    jobs = []
    page=1
    while len(jobs) < max_releases:
        r = session.get(adv, params={
            "q": query, "fl[]":["identifier","title","creator","licenseurl"],
            "output":"json", "rows":50, "page":page
        }, timeout=25)
        r.raise_for_status()
        docs = r.json().get("response",{}).get("docs",[])
        if not docs: break
        for d in docs[:max_releases-len(jobs)]:
            ident  = d.get("identifier")
            title  = d.get("title") or ident
            artist = d.get("creator") or "Unknown"
            licurl = d.get("licenseurl") or "https://archive.org/about/terms.php"
            md = session.get(f"https://archive.org/metadata/{ident}", timeout=25).json()
            files = md.get("files", [])
            urls = [f"https://archive.org/download/{ident}/{f['name']}"
                    for f in files if f.get("name","").lower().endswith((".mp3",".ogg",".m4a",".aac",".wav",".flac"))]
            jobs.append({"ident":ident,"title":title,"artist":artist,"lic":licurl,"urls":urls[:5]})
            time.sleep(0.2)
        page += 1
    return jobs

probe = discover_first_jobs('collection:netlabels AND mediatype:audio AND subject:(ambient)', max_releases=2)
probe

import sqlite3, pathlib
DB = pathlib.Path("/content/music.db") if pathlib.Path("/content/music.db").exists() else pathlib.Path("music.db")
with sqlite3.connect(DB) as con:
    cols = {r[1] for r in con.execute("PRAGMA table_info(tracks);")}
    if "genre" not in cols:
        con.execute("ALTER TABLE tracks ADD COLUMN genre TEXT;")
        print("‚úÖ added genre")
    else:
        print("‚úî genre present")

import requests, os, time, concurrent.futures, sqlite3, re
from urllib.parse import urlparse
from pathlib import Path

ASSETS = Path("/content/assets")
ASSETS.mkdir(parents=True, exist_ok=True)
DB = Path("/content/music.db")

def _safe(name:str)->str:
    return re.sub(r"[^0-9A-Za-z._ -]+","_",name).replace(" ","_")

def read_audio_metadata(path):
    # minimal placeholder (extend later with mutagen)
    return {"title": os.path.basename(path), "artist": "Unknown", "album": "", "duration": 0}

def upsert_track_full(meta, url="", license_code="", license_url="", genre_tag=""):
    with sqlite3.connect(DB) as con:
        c = con.cursor()
        c.execute("""CREATE TABLE IF NOT EXISTS tracks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT, artist TEXT, album TEXT,
            duration REAL, url TEXT, local_path TEXT,
            license_code TEXT, license_url TEXT,
            genre TEXT
        );""")
        c.execute("""INSERT INTO tracks
                     (title, artist, album, duration, url, local_path, license_code, license_url, genre)
                     VALUES (?,?,?,?,?,?,?,?,?)""",
                  (meta["title"], meta["artist"], meta["album"], meta["duration"],
                   url, str(meta.get("path", "")), license_code, license_url, genre_tag))
        con.commit()

def fast_import_from_internet_archive(query, max_items=50, max_workers=8,
                                      max_per_identifier=3, genre_tag="mixed"):
    session = requests.Session()
    search_url = "https://archive.org/advancedsearch.php"
    rows = []
    page = 1
    while len(rows) < max_items:
        r = session.get(search_url, params={
            "q": query,
            "fl[]":["identifier","title","creator","licenseurl"],
            "output":"json", "rows":50, "page":page
        }, timeout=25)
        r.raise_for_status()
        docs = r.json().get("response",{}).get("docs",[])
        if not docs: break
        rows.extend(docs)
        if len(docs) < 50: break
        page += 1
        time.sleep(0.5)
    print(f"Found {len(rows)} results")

    def download_release(doc):
        ident  = doc["identifier"]
        title  = doc.get("title") or ident
        artist = doc.get("creator") or "Unknown"
        licurl = doc.get("licenseurl") or "https://archive.org/about/terms.php"
        md = session.get(f"https://archive.org/metadata/{ident}", timeout=25).json()
        files = md.get("files", [])
        count = 0
        for f in files:
            nm = f.get("name","").lower()
            if nm.endswith((".mp3",".ogg",".m4a",".aac",".wav",".flac")):
                url = f"https://archive.org/download/{ident}/{nm}"
                local = ASSETS / _safe(f"{artist}-{title}-{nm}")
                try:
                    with requests.get(url, stream=True, timeout=30) as rr:
                        rr.raise_for_status()
                        with open(local,"wb") as ff:
                            for chunk in rr.iter_content(1024*64):
                                if chunk: ff.write(chunk)
                    meta = read_audio_metadata(local)
                    meta["path"]=local
                    upsert_track_full(meta,url=url,license_code="CC",license_url=licurl,genre_tag=genre_tag)
                    count += 1
                except Exception as e:
                    print("skip:", nm, "-", e)
                if count>=max_per_identifier: break
        return count

    total=0
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as ex:
        for n in ex.map(download_release, rows[:max_items]):
            total+=n
    print("‚úÖ downloaded & indexed", total, "tracks")
    return total

# --- FIXED, FAST, ROBUST IA IMPORTER (drop-in) ---
!pip -q install mutagen tqdm

import os, re, time, sqlite3, requests
from pathlib import Path
from urllib.parse import urlparse
from requests.adapters import HTTPAdapter, Retry
from mutagen import File as MF
from tqdm.auto import tqdm

ROOT   = Path("/content")
ASSETS = ROOT / "assets"; ASSETS.mkdir(parents=True, exist_ok=True)
DB     = ROOT / "music.db"

# --- DB schema (safe; includes genre) ---
def ensure_schema():
    with sqlite3.connect(DB) as con:
        con.execute("""
        CREATE TABLE IF NOT EXISTS tracks(
          id INTEGER PRIMARY KEY,
          title TEXT,
          artist TEXT,
          album TEXT,
          duration REAL,
          url TEXT,
          local_path TEXT,
          license_code TEXT,
          license_url TEXT,
          genre TEXT
        )""")
        # ensure genre exists even if table was older
        cols = [r[1] for r in con.execute("PRAGMA table_info(tracks);")]
        if "genre" not in cols:
            con.execute("ALTER TABLE tracks ADD COLUMN genre TEXT;")
    print("‚úÖ schema ok at", DB)

def upsert_track(meta):
    with sqlite3.connect(DB) as con:
        # If this local_path exists, update; else insert.
        row = con.execute("SELECT id FROM tracks WHERE local_path=?", (meta["local_path"],)).fetchone()
        if row:
            con.execute("""UPDATE tracks SET title=?,artist=?,album=?,duration=?,url=?,license_code=?,license_url=?,genre=COALESCE(?,genre)
                           WHERE local_path=?""",
                        (meta["title"], meta["artist"], meta["album"], float(meta["duration"] or 0),
                         meta["url"], meta["license_code"], meta["license_url"], meta["genre"], meta["local_path"]))
        else:
            con.execute("""INSERT INTO tracks(title,artist,album,duration,url,local_path,license_code,license_url,genre)
                           VALUES(?,?,?,?,?,?,?,?,?)""",
                        (meta["title"], meta["artist"], meta["album"], float(meta["duration"] or 0),
                         meta["url"], meta["local_path"], meta["license_code"], meta["license_url"], meta["genre"]))
        con.commit()

def _safe(name:str)->str:
    return re.sub(r"[^0-9A-Za-z._ -]+","_",name).strip().replace(" ","_")

def _ext_from_headers(resp, fallback=".mp3"):
    ct = (resp.headers.get("Content-Type","") or "").lower()
    if "audio/flac" in ct: return ".flac"
    if "audio/wav"  in ct or "x-wav" in ct: return ".wav"
    if "audio/ogg"  in ct: return ".ogg"
    if "audio/mpeg" in ct: return ".mp3"
    if "audio/mp4"  in ct or "aac" in ct or "m4a" in ct: return ".m4a"
    return fallback

def read_audio_metadata(path: Path):
    info = {"title": path.stem, "artist":"Unknown", "album":"Unknown", "duration":0}
    try:
        mfe = MF(path, easy=True)
        if mfe:
            info["title"]  = (mfe.get("title",  [info["title"]]) or [info["title"]])[0]
            info["artist"] = (mfe.get("artist", ["Unknown"])     or ["Unknown"])[0]
            info["album"]  = (mfe.get("album",  ["Unknown"])     or ["Unknown"])[0]
        mf = MF(path)
        if mf and getattr(mf, "info", None):
            info["duration"] = float(getattr(mf.info, "length", 0) or 0)
    except Exception:
        pass
    return info

# Shared requests Session with retries/backoff and UA
def make_session():
    s = requests.Session()
    retries = Retry(
        total=5, backoff_factor=0.6,
        status_forcelist=[429,500,502,503,504],
        allowed_methods=["GET","HEAD"]
    )
    s.mount("https://", HTTPAdapter(max_retries=retries))
    s.headers.update({"User-Agent": "Mozilla/5.0 (TheVoidSpeaks/1.0)"})
    return s

# Keep filename CASE for URL; only use lower() for extension check
def pick_audio_files(files, max_per_identifier=3):
    picked = []
    for f in files:
        name_orig = f.get("name","")         # keep original case
        name_lc   = name_orig.lower()
        if name_lc.endswith((".mp3",".ogg",".m4a",".aac",".wav",".flac")):
            picked.append(name_orig)
        if len(picked) >= max_per_identifier:
            break
    return picked

def fast_import_from_internet_archive(
    query="collection:netlabels AND mediatype:audio",
    max_items=100,
    max_workers=8,
    max_per_identifier=3,
    genre_tag=None,
    polite_delay=0.2
):
    ensure_schema()
    s = make_session()

    # 1) discover identifiers/releases
    jobs = []
    page = 1
    adv = "https://archive.org/advancedsearch.php"
    with tqdm(desc="Discovering", unit="rel") as pbar:
        while len(jobs) < max_items:
            r = s.get(adv, params={
                "q": query,
                "fl[]": ["identifier","title","creator","licenseurl"],
                "output": "json",
                "rows": 50,
                "page": page
            }, timeout=25)
            r.raise_for_status()
            docs = r.json().get("response",{}).get("docs",[])
            if not docs:
                break
            for d in docs:
                if len(jobs) >= max_items: break
                ident  = d.get("identifier")
                title  = d.get("title") or ident
                artist = d.get("creator") or "Unknown"
                licurl = d.get("licenseurl") or "https://archive.org/about/terms.php"
                md = s.get(f"https://archive.org/metadata/{ident}", timeout=25).json()
                files = md.get("files", [])
                picks = pick_audio_files(files, max_per_identifier=max_per_identifier)
                for fname in picks:
                    url = f"https://archive.org/download/{ident}/{fname}"  # ‚úÖ original case
                    jobs.append({
                        "url": url, "title": title, "artist": artist, "album": ident,
                        "license_code": "CC/PD", "license_url": licurl, "genre": genre_tag
                    })
                time.sleep(polite_delay)
            page += 1
            pbar.update(1)

    if not jobs:
        print("No candidates found for query.")
        return 0

    # 2) download sequentially (safer for IA; still fast enough)
    ok = 0; fail = 0
    for j in tqdm(jobs, desc="Downloading", unit="trk"):
        try:
            # decide filename from artist-title + server ext
            ext = os.path.splitext(urlparse(j["url"]).path)[1] or ".mp3"
            fname = _safe(f"{j['artist']}-{j['title']}{ext}")
            out = ASSETS / fname

            if out.exists() and out.stat().st_size > 0:
                meta = read_audio_metadata(out)
                upsert_track({
                    "title":  meta["title"] or j["title"],
                    "artist": meta["artist"] or j["artist"],
                    "album":  meta["album"]  or j["album"],
                    "duration": meta["duration"] or 0,
                    "url": j["url"],
                    "local_path": str(out),
                    "license_code": j["license_code"],
                    "license_url": j["license_url"],
                    "genre": j["genre"]
                })
                ok += 1
                continue

            with s.get(j["url"], stream=True, timeout=45) as r:
                r.raise_for_status()
                # adjust ext if Content-Type says different
                real_ext = _ext_from_headers(r, ext or ".mp3")
                if real_ext and real_ext != ext:
                    ext = real_ext
                    fname = _safe(f"{j['artist']}-{j['title']}{ext}")
                    out = ASSETS / fname
                with open(out, "wb") as f:
                    for chunk in r.iter_content(1024*64):
                        if chunk: f.write(chunk)

            meta = read_audio_metadata(out)
            upsert_track({
                "title":  meta["title"] or j["title"],
                "artist": meta["artist"] or j["artist"],
                "album":  meta["album"]  or j["album"],
                "duration": meta["duration"] or 0,
                "url": j["url"],
                "local_path": str(out),
                "license_code": j["license_code"],
                "license_url": j["license_url"],
                "genre": j["genre"]
            })
            ok += 1
        except Exception as e:
            print("skip:", j["url"], "-", type(e).__name__, e)
            fail += 1

    print(f"Done: {ok} ok, {fail} skipped/failed")
    return ok

import sqlite3, pathlib
DB = pathlib.Path("/content/music.db")

with sqlite3.connect(DB) as con:
    cur = con.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS tracks(
      id INTEGER PRIMARY KEY,
      title TEXT,
      artist TEXT,
      album TEXT,
      duration REAL,
      url TEXT,
      local_path TEXT,
      license_code TEXT,
      license_url TEXT,
      genre TEXT
    )
    """)
    cols = [r[1] for r in cur.execute("PRAGMA table_info(tracks);")]

    need = {
        "license_code": "TEXT",
        "license_url": "TEXT",
        "genre": "TEXT",
        "duration": "REAL",
        "local_path": "TEXT"
    }
    for col, sqltype in need.items():
        if col not in cols:
            cur.execute(f"ALTER TABLE tracks ADD COLUMN {col} {sqltype};")

    con.commit()
print("‚úÖ Database schema fixed and ready.")

fast_import_from_internet_archive(
    query='collection:netlabels AND mediatype:audio AND subject:(ambient)',
    max_items=20,
    max_per_identifier=2,
    genre_tag="ambient"
)

genres = {
    "ambient": "collection:netlabels AND mediatype:audio AND subject:(ambient OR atmosphere)",
    "lofi": "collection:netlabels AND mediatype:audio AND subject:(lofi OR chillhop OR chill)",
    "electronic": "collection:netlabels AND mediatype:audio AND subject:(electronic OR synth OR downtempo)",
    "rock": "collection:netlabels AND mediatype:audio AND subject:(rock OR alternative OR indie)",
    "jazz": "collection:netlabels AND mediatype:audio AND subject:(jazz OR blues OR swing)",
    "hiphop": "collection:netlabels AND mediatype:audio AND subject:(hiphop OR rap OR beats)",
}

for g, q in genres.items():
    fast_import_from_internet_archive(query=q, max_items=1000, max_per_identifier=3, genre_tag=g)

# --- THE VOID SPEAKS ‚Äî Database-powered Streamlit app ---
import streamlit as st
import pandas as pd
import sqlite3, os

# üéµ Path to your SQLite DB (from DBpro.ipynb)
DB_PATH = "music.db"

# --- Load function ---
def load_tracks(query=""):
    """Load tracks from the SQLite database (searchable by title, artist, or genre)."""
    if not os.path.exists(DB_PATH):
        st.error(f"Database not found at {DB_PATH}")
        return pd.DataFrame(columns=["title","artist","genre","local_path"])

    con = sqlite3.connect(DB_PATH)
    if query:
        sql = """SELECT title, artist, album, genre, local_path, url
                 FROM tracks
                 WHERE title LIKE ? OR artist LIKE ? OR genre LIKE ?
                 LIMIT 200"""
        df = pd.read_sql_query(sql, con, params=[f"%{query}%", f"%{query}%", f"%{query}%"])
    else:
        df = pd.read_sql_query("SELECT title, artist, album, genre, local_path, url FROM tracks ORDER BY RANDOM() LIMIT 200", con)
    con.close()
    return df

# --- Streamlit interface ---
st.set_page_config(page_title="THE VOID SPEAKS", layout="wide")
st.markdown("<h1 style='text-align:center;color:#C6B8FF;'>üåå THE VOID SPEAKS</h1>", unsafe_allow_html=True)

q = st.text_input("Search by title / artist / genre", "")

lib = load_tracks(q)

if len(lib) == 0:
    st.warning("No tracks found.")
else:
    for _, r in lib.iterrows():
        st.markdown(f"**{r.get('title','Unknown')}** ‚Äî *{r.get('artist','Unknown')}*  ¬∑  `{r.get('genre','')}`")
        lp = r.get("local_path", "")
        if isinstance(lp, str) and os.path.exists(lp):
            st.audio(lp)
        elif r.get("url"):
            st.audio(r["url"])

app_code = '''
import streamlit as st
import pandas as pd
import sqlite3, os

DB_PATH = "music.db"

def load_tracks(query=""):
    if not os.path.exists(DB_PATH):
        st.error(f"Database not found at {DB_PATH}")
        return pd.DataFrame(columns=["title","artist","genre","local_path"])

    con = sqlite3.connect(DB_PATH)
    if query:
        sql = """SELECT title, artist, album, genre, local_path, url
                 FROM tracks
                 WHERE title LIKE ? OR artist LIKE ? OR genre LIKE ?
                 LIMIT 200"""
        df = pd.read_sql_query(sql, con, params=[f"%{query}%", f"%{query}%", f"%{query}%"])
    else:
        df = pd.read_sql_query("SELECT title, artist, album, genre, local_path, url FROM tracks ORDER BY RANDOM() LIMIT 200", con)
    con.close()
    return df

st.set_page_config(page_title="THE VOID SPEAKS", layout="wide")
st.markdown("<h1 style='text-align:center;color:#C6B8FF;'>üåå THE VOID SPEAKS</h1>", unsafe_allow_html=True)

q = st.text_input("Search by title / artist / genre", "")
lib = load_tracks(q)

if len(lib) == 0:
    st.warning("No tracks found.")
else:
    for _, r in lib.iterrows():
        st.markdown(f"**{r.get('title','Unknown')}** ‚Äî *{r.get('artist','Unknown')}*  ¬∑  `{r.get('genre','')}`")
        lp = r.get("local_path", "")
        if isinstance(lp, str) and os.path.exists(lp):
            st.audio(lp)
        elif r.get("url"):
            st.audio(r["url"])
'''

# Write it to a file
with open("app.py", "w", encoding="utf-8") as f:
    f.write(app_code)
print("‚úÖ Created app.py successfully")

import sqlite3, pandas as pd
conn = sqlite3.connect("music.db")
print(pd.read_sql_query("SELECT COUNT(*) FROM tracks", conn))

# Install once
!pip -q install mutagen tqdm

import os, time, sqlite3
from pathlib import Path
from mutagen import File as MF
from tqdm.auto import tqdm

# ====== EDIT THESE IF YOUR PATHS ARE DIFFERENT ======
ASSETS = Path("/content/assets")      # where your audio files were downloaded
DB     = Path("/content/music.db")    # where to create/update the database
# ====================================================

ASSETS.mkdir(parents=True, exist_ok=True)

def ensure_schema(con):
    con.executescript("""
    CREATE TABLE IF NOT EXISTS tracks(
        id INTEGER PRIMARY KEY,
        title TEXT,
        artist TEXT,
        album TEXT,
        duration REAL,
        genre TEXT,
        url TEXT,
        local_path TEXT UNIQUE,   -- dedupe by file path
        license_code TEXT,
        license_url TEXT,
        added_at INTEGER
    );
    """)
    con.commit()

def read_tags(path: Path):
    """Read basic tags; fall back to sensible defaults."""
    meta = {
        "title":  path.stem,
        "artist": "Unknown",
        "album":  "",
        "duration": 0.0,
        "genre":   ""
    }
    try:
        m_easy = MF(path, easy=True)
        if m_easy:
            meta["title"]  = (m_easy.get("title",  [meta["title"]]) or [meta["title"]])[0]
            meta["artist"] = (m_easy.get("artist", ["Unknown"])     or ["Unknown"])[0]
            meta["album"]  = (m_easy.get("album",  [""])            or [""])[0]
            meta["genre"]  = (m_easy.get("genre",  [""])            or [""])[0]
        m_full = MF(path)
        if m_full and getattr(m_full, "info", None):
            meta["duration"] = float(getattr(m_full.info, "length", 0) or 0)
    except Exception:
        pass

    # if genre still empty, infer from parent folder name
    if not meta["genre"]:
        parent = path.parent.name
        meta["genre"] = parent if parent != ASSETS.name else ""
    return meta

# Gather all audio files
AUDIO_EXTS = {".mp3", ".ogg", ".m4a", ".aac", ".flac", ".wav"}
files = [p for p in ASSETS.rglob("*") if p.suffix.lower() in AUDIO_EXTS]
print(f"üéµ Found {len(files)} audio files under {ASSETS}")

# Build / update DB
con = sqlite3.connect(DB)
ensure_schema(con)

added = 0
for p in tqdm(files, desc="Indexing"):
    meta = read_tags(p)
    con.execute(
        """
        INSERT INTO tracks (title, artist, album, duration, genre, url, local_path, license_code, license_url, added_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(local_path) DO UPDATE SET
            title=excluded.title,
            artist=excluded.artist,
            album=excluded.album,
            duration=excluded.duration,
            -- keep existing genre unless new one is non-empty
            genre=CASE WHEN excluded.genre IS NOT NULL AND excluded.genre != '' THEN excluded.genre ELSE tracks.genre END
        """,
        (
            meta["title"], meta["artist"], meta["album"], meta["duration"], meta["genre"],
            "",                     # url unknown for local files (leave blank)
            str(p),                 # absolute path for offline playback
            "", "",                 # license_code / license_url (fill later if you have them)
            int(time.time()),
        ),
    )
    added += 1

con.commit()
total = con.execute("SELECT COUNT(*) FROM tracks").fetchone()[0]
con.close()
print(f"‚úÖ Indexed {added} files. DB ready at: {DB}  | total rows: {total}")

# Mount Drive (safe to run even if already mounted)
from google.colab import drive
drive.mount('/content/drive', force_remount=False)

import os, sys
from pathlib import Path
from collections import Counter

AUDIO_EXTS = {".mp3",".ogg",".m4a",".aac",".flac",".wav"}

def scan(root: Path, limit=10):
    root = Path(root)
    hits = []
    if not root.exists():
        return root, 0, []
    for p in root.rglob("*"):
        if p.suffix.lower() in AUDIO_EXTS:
            hits.append(p)
    sample = [str(p) for p in hits[:limit]]
    return root, len(hits), sample

candidates = [
    Path("/content/assets"),
    Path("/content"),
    Path("/content/drive/MyDrive"),
    Path("/content/drive/MyDrive/the_void_speaks"),
    Path("/content/drive"),
]

print("üîé scanning common locations...")
found = []
for c in candidates:
    root, n, sample = scan(c, limit=5)
    print(f"{str(root):<45} -> {n} audio files")
    if sample:
        for s in sample:
            print("   ‚Ä¢", s)
    if n>0:
        found.append((root, n, sample))

if not found:
    print("\n‚ö†Ô∏è No audio found in the usual places. If you know the folder, paste its full path below.")
else:
    # pick the dir with most files as default source
    found.sort(key=lambda x: x[1], reverse=True)
    BEST_ROOT = found[0][0]
    print(f"\n‚úÖ Likely source folder: {BEST_ROOT}")

from google.colab import files
up = files.upload()  # choose your file in the dialog

!pip -q install mutagen

import os, time, sqlite3, shutil
from pathlib import Path
from mutagen import File as MF

# paths
ASSETS = Path("/content/assets"); ASSETS.mkdir(parents=True, exist_ok=True)
DB     = Path("/content/music.db")

# get uploaded filename
src_name = next(iter(up.keys()))
src_path = Path(src_name)

# move to assets/
dst_path = ASSETS / src_path.name
shutil.move(str(src_path), str(dst_path))
print("‚úÖ moved to:", dst_path)

# ensure schema
con = sqlite3.connect(DB)
con.executescript("""
CREATE TABLE IF NOT EXISTS tracks(
  id INTEGER PRIMARY KEY,
  title TEXT,
  artist TEXT,
  album TEXT,
  duration REAL,
  genre TEXT,
  url TEXT,
  local_path TEXT UNIQUE,
  license_code TEXT,
  license_url TEXT,
  added_at INTEGER
);
""")

# read tags
def read_tags(p: Path):
    meta = {"title": p.stem, "artist":"Unknown", "album":"", "duration":0.0, "genre":""}
    try:
        easy = MF(p, easy=True)
        if easy:
            meta["title"]  = (easy.get("title",  [meta["title"]]) or [meta["title"]])[0]
            meta["artist"] = (easy.get("artist", ["Unknown"])     or ["Unknown"])[0]
            meta["album"]  = (easy.get("album",  [""])            or [""])[0]
            meta["genre"]  = (easy.get("genre",  [""])            or [""])[0]
        full = MF(p)
        if full and getattr(full, "info", None):
            meta["duration"] = float(getattr(full.info, "length", 0) or 0)
    except Exception:
        pass
    return meta

m = read_tags(dst_path)

# upsert (dedupe by local_path)
con.execute("""
INSERT INTO tracks (title,artist,album,duration,genre,url,local_path,license_code,license_url,added_at)
VALUES (?,?,?,?,?,?,?,?,?,?)
ON CONFLICT(local_path) DO UPDATE SET
  title=excluded.title,
  artist=excluded.artist,
  album=excluded.album,
  duration=excluded.duration,
  genre=CASE WHEN excluded.genre!='' THEN excluded.genre ELSE tracks.genre END
""", (m["title"], m["artist"], m["album"], m["duration"], m["genre"],
      "", str(dst_path), "", "", int(time.time())))
con.commit()

total = con.execute("SELECT COUNT(*) FROM tracks").fetchone()[0]
row   = con.execute("SELECT title,artist,local_path FROM tracks ORDER BY id DESC LIMIT 1").fetchone()
con.close()

print(f"üéµ indexed: {row}")
print(f"üìä total tracks in DB: {total}")
print("üìç DB at:", DB)

import sqlite3, time, os
from pathlib import Path

DB_PATH = Path("music.db")

con = sqlite3.connect(DB_PATH)
con.executescript("""
DROP TABLE IF EXISTS tracks;
CREATE TABLE tracks (
    id INTEGER PRIMARY KEY,
    title TEXT,
    artist TEXT,
    album TEXT,
    duration REAL,
    genre TEXT,
    url TEXT,
    local_path TEXT UNIQUE,
    license_code TEXT,
    license_url TEXT,
    added_at INTEGER
);
""")
con.commit()
con.close()
print("‚úÖ Fresh music.db created.")

from mutagen import File as MF

song_path = Path("@FORCEPARKBOISWORLDWIDE - LOTUS.mp3")  # put the real name here
meta = {"title": song_path.stem, "artist": "Unknown", "album": "", "duration": 0.0, "genre": ""}

try:
    m = MF(song_path, easy=True)
    if m:
        meta["title"]  = (m.get("title",  [meta["title"]]) or [meta["title"]])[0]
        meta["artist"] = (m.get("artist", ["Unknown"])     or ["Unknown"])[0]
        meta["album"]  = (m.get("album",  [""])            or [""])[0]
        meta["genre"]  = (m.get("genre",  [""])            or [""])[0]
    full = MF(song_path)
    if full and getattr(full, "info", None):
        meta["duration"] = float(getattr(full.info, "length", 0) or 0)
except Exception:
    pass

con = sqlite3.connect(DB_PATH)
con.execute("""
INSERT INTO tracks (title,artist,album,duration,genre,url,local_path,license_code,license_url,added_at)
VALUES (?,?,?,?,?,?,?,?,?,?)
""", (meta["title"], meta["artist"], meta["album"], meta["duration"], meta["genre"],
      "", str(song_path), "", "", int(time.time())))
con.commit()
con.close()
print("‚úÖ Song added to database:", meta["title"])

import pandas as pd
con = sqlite3.connect(DB_PATH)
print(pd.read_sql_query("SELECT title, artist, local_path FROM tracks", con))
con.close()

